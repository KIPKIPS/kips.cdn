!function(){const _q=new THREE.Quaternion,_targetPos=new THREE.Vector3,_targetVec=new THREE.Vector3,_effectorPos=new THREE.Vector3,_effectorVec=new THREE.Vector3,_linkPos=new THREE.Vector3,_invLinkQ=new THREE.Quaternion,_linkScale=new THREE.Vector3,_axis=new THREE.Vector3,_vector=new THREE.Vector3,_matrix=new THREE.Matrix4;class CCDIKSolver{constructor(mesh,iks=[]){this.mesh=mesh,this.iks=iks,this._valid()}update(){const iks=this.iks;for(let i=0,il=iks.length;i<il;i++)this.updateOne(iks[i]);return this}updateOne(ik){const bones=this.mesh.skeleton.bones,math=Math,effector=bones[ik.effector],target=bones[ik.target];_targetPos.setFromMatrixPosition(target.matrixWorld);const links=ik.links,iteration=void 0!==ik.iteration?ik.iteration:1;for(let i=0;i<iteration;i++){let rotated=!1;for(let j=0,jl=links.length;j<jl;j++){const link=bones[links[j].index];if(!1===links[j].enabled)break;const limitation=links[j].limitation,rotationMin=links[j].rotationMin,rotationMax=links[j].rotationMax;link.matrixWorld.decompose(_linkPos,_invLinkQ,_linkScale),_invLinkQ.invert(),_effectorPos.setFromMatrixPosition(effector.matrixWorld),_effectorVec.subVectors(_effectorPos,_linkPos),_effectorVec.applyQuaternion(_invLinkQ),_effectorVec.normalize(),_targetVec.subVectors(_targetPos,_linkPos),_targetVec.applyQuaternion(_invLinkQ),_targetVec.normalize();let angle=_targetVec.dot(_effectorVec);if(angle>1?angle=1:angle<-1&&(angle=-1),angle=math.acos(angle),!(angle<1e-5)){if(void 0!==ik.minAngle&&angle<ik.minAngle&&(angle=ik.minAngle),void 0!==ik.maxAngle&&angle>ik.maxAngle&&(angle=ik.maxAngle),_axis.crossVectors(_effectorVec,_targetVec),_axis.normalize(),_q.setFromAxisAngle(_axis,angle),link.quaternion.multiply(_q),void 0!==limitation){let c=link.quaternion.w;c>1&&(c=1);const c2=math.sqrt(1-c*c);link.quaternion.set(limitation.x*c2,limitation.y*c2,limitation.z*c2,c)}void 0!==rotationMin&&link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin)),void 0!==rotationMax&&link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax)),link.updateMatrixWorld(!0),rotated=!0}}if(!rotated)break}return this}createHelper(){return new CCDIKHelper(this.mesh,this.mesh.geometry.userData.MMD.iks)}_valid(){const iks=this.iks,bones=this.mesh.skeleton.bones;for(let i=0,il=iks.length;i<il;i++){const ik=iks[i],effector=bones[ik.effector],links=ik.links;let link0,link1;link0=effector;for(let j=0,jl=links.length;j<jl;j++)link1=bones[links[j].index],link0.parent!==link1&&console.warn("THREE.CCDIKSolver: bone "+link0.name+" is not the child of bone "+link1.name),link0=link1}}}function getPosition(bone,matrixWorldInv){return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv)}function setPositionOfBoneToAttributeArray(array,index,bone,matrixWorldInv){const v=getPosition(bone,matrixWorldInv);array[3*index+0]=v.x,array[3*index+1]=v.y,array[3*index+2]=v.z}class CCDIKHelper extends THREE.Object3D{constructor(mesh,iks=[],sphereSize=.25){super(),this.root=mesh,this.iks=iks,this.matrix.copy(mesh.matrixWorld),this.matrixAutoUpdate=!1,this.sphereGeometry=new THREE.SphereGeometry(sphereSize,16,8),this.targetSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(16746632),depthTest:!1,depthWrite:!1,transparent:!0}),this.effectorSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(8978312),depthTest:!1,depthWrite:!1,transparent:!0}),this.linkSphereMaterial=new THREE.MeshBasicMaterial({color:new THREE.Color(8947967),depthTest:!1,depthWrite:!1,transparent:!0}),this.lineMaterial=new THREE.LineBasicMaterial({color:new THREE.Color(16711680),depthTest:!1,depthWrite:!1,transparent:!0}),this._init()}updateMatrixWorld(force){const mesh=this.root;if(this.visible){let offset=0;const iks=this.iks,bones=mesh.skeleton.bones;_matrix.copy(mesh.matrixWorld).invert();for(let i=0,il=iks.length;i<il;i++){const ik=iks[i],targetBone=bones[ik.target],effectorBone=bones[ik.effector],targetMesh=this.children[offset++],effectorMesh=this.children[offset++];targetMesh.position.copy(getPosition(targetBone,_matrix)),effectorMesh.position.copy(getPosition(effectorBone,_matrix));for(let j=0,jl=ik.links.length;j<jl;j++){const link=ik.links[j],linkBone=bones[link.index],linkMesh=this.children[offset++];linkMesh.position.copy(getPosition(linkBone,_matrix))}const line=this.children[offset++],array=line.geometry.attributes.position.array;setPositionOfBoneToAttributeArray(array,0,targetBone,_matrix),setPositionOfBoneToAttributeArray(array,1,effectorBone,_matrix);for(let j=0,jl=ik.links.length;j<jl;j++){const link=ik.links[j],linkBone=bones[link.index];setPositionOfBoneToAttributeArray(array,j+2,linkBone,_matrix)}line.geometry.attributes.position.needsUpdate=!0}}this.matrix.copy(mesh.matrixWorld),super.updateMatrixWorld(force)}dispose(){this.sphereGeometry.dispose(),this.targetSphereMaterial.dispose(),this.effectorSphereMaterial.dispose(),this.linkSphereMaterial.dispose(),this.lineMaterial.dispose();const children=this.children;for(let i=0;i<children.length;i++){const child=children[i];child.isLine&&child.geometry.dispose()}}_init(){const scope=this,iks=this.iks;function createLineGeometry(ik){const geometry=new THREE.BufferGeometry,vertices=new Float32Array(3*(2+ik.links.length));return geometry.setAttribute("position",new THREE.BufferAttribute(vertices,3)),geometry}function createTargetMesh(){return new THREE.Mesh(scope.sphereGeometry,scope.targetSphereMaterial)}function createEffectorMesh(){return new THREE.Mesh(scope.sphereGeometry,scope.effectorSphereMaterial)}function createLinkMesh(){return new THREE.Mesh(scope.sphereGeometry,scope.linkSphereMaterial)}function createLine(ik){return new THREE.Line(createLineGeometry(ik),scope.lineMaterial)}for(let i=0,il=iks.length;i<il;i++){const ik=iks[i];this.add(createTargetMesh()),this.add(createEffectorMesh());for(let j=0,jl=ik.links.length;j<jl;j++)this.add(createLinkMesh());this.add(createLine(ik))}}}THREE.CCDIKHelper=CCDIKHelper,THREE.CCDIKSolver=CCDIKSolver}();