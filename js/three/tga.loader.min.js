!function(){class TGALoader extends THREE.DataTextureLoader{constructor(manager){super(manager)}parse(buffer){function tgaCheckHeader(header){switch(header.image_type){case TGA_TYPE_INDEXED:case TGA_TYPE_RLE_INDEXED:(header.colormap_length>256||24!==header.colormap_size||1!==header.colormap_type)&&console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");break;case TGA_TYPE_RGB:case TGA_TYPE_GREY:case TGA_TYPE_RLE_RGB:case TGA_TYPE_RLE_GREY:header.colormap_type&&console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");break;case TGA_TYPE_NO_DATA:console.error("THREE.TGALoader: No data.");default:console.error('THREE.TGALoader: Invalid type "%s".',header.image_type)}(header.width<=0||header.height<=0)&&console.error("THREE.TGALoader: Invalid image size."),8!==header.pixel_size&&16!==header.pixel_size&&24!==header.pixel_size&&32!==header.pixel_size&&console.error('THREE.TGALoader: Invalid pixel size "%s".',header.pixel_size)}function tgaParse(use_rle,use_pal,header,offset,data){let pixel_data,palettes;const pixel_size=header.pixel_size>>3,pixel_total=header.width*header.height*pixel_size;if(use_pal&&(palettes=data.subarray(offset,offset+=header.colormap_length*(header.colormap_size>>3))),use_rle){let c,count,i;pixel_data=new Uint8Array(pixel_total);let shift=0;const pixels=new Uint8Array(pixel_size);for(;shift<pixel_total;)if(c=data[offset++],count=1+(127&c),128&c){for(i=0;i<pixel_size;++i)pixels[i]=data[offset++];for(i=0;i<count;++i)pixel_data.set(pixels,shift+i*pixel_size);shift+=pixel_size*count}else{for(count*=pixel_size,i=0;i<count;++i)pixel_data[shift+i]=data[offset++];shift+=count}}else pixel_data=data.subarray(offset,offset+=use_pal?header.width*header.height:pixel_total);return{pixel_data:pixel_data,palettes:palettes}}function tgaGetImageData8bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image,palettes){const colormap=palettes;let color,i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i++)color=image[i],imageData[4*(x+width*y)+3]=255,imageData[4*(x+width*y)+2]=colormap[3*color+0],imageData[4*(x+width*y)+1]=colormap[3*color+1],imageData[4*(x+width*y)+0]=colormap[3*color+2];return imageData}function tgaGetImageData16bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){let color,i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i+=2)color=image[i+0]+(image[i+1]<<8),imageData[4*(x+width*y)+0]=(31744&color)>>7,imageData[4*(x+width*y)+1]=(992&color)>>2,imageData[4*(x+width*y)+2]=(31&color)<<3,imageData[4*(x+width*y)+3]=32768&color?0:255;return imageData}function tgaGetImageData24bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){let i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i+=3)imageData[4*(x+width*y)+3]=255,imageData[4*(x+width*y)+2]=image[i+0],imageData[4*(x+width*y)+1]=image[i+1],imageData[4*(x+width*y)+0]=image[i+2];return imageData}function tgaGetImageData32bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){let i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i+=4)imageData[4*(x+width*y)+2]=image[i+0],imageData[4*(x+width*y)+1]=image[i+1],imageData[4*(x+width*y)+0]=image[i+2],imageData[4*(x+width*y)+3]=image[i+3];return imageData}function tgaGetImageDataGrey8bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){let color,i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i++)color=image[i],imageData[4*(x+width*y)+0]=color,imageData[4*(x+width*y)+1]=color,imageData[4*(x+width*y)+2]=color,imageData[4*(x+width*y)+3]=255;return imageData}function tgaGetImageDataGrey16bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){let i=0,x,y;const width=header.width;for(y=y_start;y!==y_end;y+=y_step)for(x=x_start;x!==x_end;x+=x_step,i+=2)imageData[4*(x+width*y)+0]=image[i+0],imageData[4*(x+width*y)+1]=image[i+0],imageData[4*(x+width*y)+2]=image[i+0],imageData[4*(x+width*y)+3]=image[i+1];return imageData}function getTgaRGBA(data,width,height,image,palette){let x_start,y_start,x_step,y_step,x_end,y_end;switch((header.flags&TGA_ORIGIN_MASK)>>TGA_ORIGIN_SHIFT){default:case TGA_ORIGIN_UL:x_start=0,x_step=1,x_end=width,y_start=0,y_step=1,y_end=height;break;case TGA_ORIGIN_BL:x_start=0,x_step=1,x_end=width,y_start=height-1,y_step=-1,y_end=-1;break;case TGA_ORIGIN_UR:x_start=width-1,x_step=-1,x_end=-1,y_start=0,y_step=1,y_end=height;break;case TGA_ORIGIN_BR:x_start=width-1,x_step=-1,x_end=-1,y_start=height-1,y_step=-1,y_end=-1}if(use_grey)switch(header.pixel_size){case 8:tgaGetImageDataGrey8bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);break;case 16:tgaGetImageDataGrey16bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);break;default:console.error("THREE.TGALoader: Format not supported.")}else switch(header.pixel_size){case 8:tgaGetImageData8bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image,palette);break;case 16:tgaGetImageData16bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);break;case 24:tgaGetImageData24bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);break;case 32:tgaGetImageData32bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);break;default:console.error("THREE.TGALoader: Format not supported.")}return data}const TGA_TYPE_NO_DATA=0,TGA_TYPE_INDEXED=1,TGA_TYPE_RGB=2,TGA_TYPE_GREY=3,TGA_TYPE_RLE_INDEXED=9,TGA_TYPE_RLE_RGB=10,TGA_TYPE_RLE_GREY=11,TGA_ORIGIN_MASK=48,TGA_ORIGIN_SHIFT=4,TGA_ORIGIN_BL=0,TGA_ORIGIN_BR=1,TGA_ORIGIN_UL=2,TGA_ORIGIN_UR=3;buffer.length<19&&console.error("THREE.TGALoader: Not enough data to contain header.");let offset=0;const content=new Uint8Array(buffer),header={id_length:content[offset++],colormap_type:content[offset++],image_type:content[offset++],colormap_index:content[offset++]|content[offset++]<<8,colormap_length:content[offset++]|content[offset++]<<8,colormap_size:content[offset++],origin:[content[offset++]|content[offset++]<<8,content[offset++]|content[offset++]<<8],width:content[offset++]|content[offset++]<<8,height:content[offset++]|content[offset++]<<8,pixel_size:content[offset++],flags:content[offset++]};tgaCheckHeader(header),header.id_length+offset>buffer.length&&console.error("THREE.TGALoader: No data."),offset+=header.id_length;let use_rle=!1,use_pal=!1,use_grey=!1;switch(header.image_type){case TGA_TYPE_RLE_INDEXED:use_rle=!0,use_pal=!0;break;case TGA_TYPE_INDEXED:use_pal=!0;break;case TGA_TYPE_RLE_RGB:use_rle=!0;break;case TGA_TYPE_RGB:break;case TGA_TYPE_RLE_GREY:use_rle=!0,use_grey=!0;break;case TGA_TYPE_GREY:use_grey=!0}const imageData=new Uint8Array(header.width*header.height*4),result=tgaParse(use_rle,use_pal,header,offset,content);return getTgaRGBA(imageData,header.width,header.height,result.pixel_data,result.palettes),{data:imageData,width:header.width,height:header.height,flipY:!0,generateMipmaps:!0,minFilter:THREE.LinearMipmapLinearFilter}}}THREE.TGALoader=TGALoader}();