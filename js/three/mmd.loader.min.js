!function(){class MMDLoader extends THREE.Loader{constructor(manager){super(manager),this.loader=new THREE.FileLoader(this.manager),this.parser=null,this.meshBuilder=new MeshBuilder(this.manager),this.animationBuilder=new AnimationBuilder}setAnimationPath(animationPath){return this.animationPath=animationPath,this}load(url,onLoad,onProgress,onError){const builder=this.meshBuilder.setCrossOrigin(this.crossOrigin);let resourcePath;resourcePath=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:THREE.LoaderUtils.extractUrlBase(url);const modelExtension=this._extractExtension(url).toLowerCase();"pmd"===modelExtension||"pmx"===modelExtension?this["pmd"===modelExtension?"loadPMD":"loadPMX"](url,(function(data){onLoad(builder.build(data,resourcePath,onProgress,onError))}),onProgress,onError):onError&&onError(new Error("THREE.MMDLoader: Unknown model file extension ."+modelExtension+"."))}loadAnimation(url,object,onLoad,onProgress,onError){const builder=this.animationBuilder;this.loadVMD(url,(function(vmd){onLoad(object.isCamera?builder.buildCameraAnimation(vmd):builder.build(vmd,object))}),onProgress,onError)}loadWithAnimation(modelUrl,vmdUrl,onLoad,onProgress,onError){const scope=this;this.load(modelUrl,(function(mesh){scope.loadAnimation(vmdUrl,mesh,(function(animation){onLoad({mesh:mesh,animation:animation})}),onProgress,onError)}),onProgress,onError)}loadPMD(url,onLoad,onProgress,onError){const parser=this._getParser();this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url,(function(buffer){onLoad(parser.parsePmd(buffer,!0))}),onProgress,onError)}loadPMX(url,onLoad,onProgress,onError){const parser=this._getParser();this.loader.setMimeType(void 0).setPath(this.path).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url,(function(buffer){onLoad(parser.parsePmx(buffer,!0))}),onProgress,onError)}loadVMD(url,onLoad,onProgress,onError){const urls=Array.isArray(url)?url:[url],vmds=[],vmdNum=urls.length,parser=this._getParser();this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType("arraybuffer").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);for(let i=0,il=urls.length;i<il;i++)this.loader.load(urls[i],(function(buffer){vmds.push(parser.parseVmd(buffer,!0)),vmds.length===vmdNum&&onLoad(parser.mergeVmds(vmds))}),onProgress,onError)}loadVPD(url,isUnicode,onLoad,onProgress,onError){const parser=this._getParser();this.loader.setMimeType(isUnicode?void 0:"text/plain; charset=shift_jis").setPath(this.animationPath).setResponseType("text").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url,(function(text){onLoad(parser.parseVpd(text,!0))}),onProgress,onError)}_extractExtension(url){const index=url.lastIndexOf(".");return index<0?"":url.slice(index+1)}_getParser(){if(null===this.parser){if("undefined"==typeof MMDParser)throw new Error("THREE.MMDLoader: Import MMDParser https://github.com/takahirox/mmd-parser");this.parser=new MMDParser.Parser}return this.parser}}const DEFAULT_TOON_TEXTURES=["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII="],NON_ALPHA_CHANNEL_FORMATS=[THREE.RGB_S3TC_DXT1_Format,THREE.RGB_PVRTC_4BPPV1_Format,THREE.RGB_PVRTC_2BPPV1_Format,THREE.RGB_ETC1_Format,THREE.RGB_ETC2_Format];class MeshBuilder{constructor(manager){this.crossOrigin="anonymous",this.geometryBuilder=new GeometryBuilder,this.materialBuilder=new MaterialBuilder(manager)}setCrossOrigin(crossOrigin){return this.crossOrigin=crossOrigin,this}build(data,resourcePath,onProgress,onError){const geometry=this.geometryBuilder.build(data),material=this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data,geometry,onProgress,onError),mesh=new THREE.SkinnedMesh(geometry,material),skeleton=new THREE.Skeleton(initBones(mesh));return mesh.bind(skeleton),mesh}}function initBones(mesh){const geometry=mesh.geometry,bones=[];if(geometry&&void 0!==geometry.bones){for(let i=0,il=geometry.bones.length;i<il;i++){const gbone=geometry.bones[i],bone=new THREE.Bone;bones.push(bone),bone.name=gbone.name,bone.position.fromArray(gbone.pos),bone.quaternion.fromArray(gbone.rotq),void 0!==gbone.scl&&bone.scale.fromArray(gbone.scl)}for(let i=0,il=geometry.bones.length;i<il;i++){const gbone=geometry.bones[i];-1!==gbone.parent&&null!==gbone.parent&&void 0!==bones[gbone.parent]?bones[gbone.parent].add(bones[i]):mesh.add(bones[i])}}return mesh.updateMatrixWorld(!0),bones}class GeometryBuilder{build(data){const positions=[],uvs=[],normals=[],indices=[],groups=[],bones=[],skinIndices=[],skinWeights=[],morphTargets=[],morphPositions=[],iks=[],grants=[],rigidBodies=[],constraints=[];let offset=0;const boneTypeTable={};for(let i=0;i<data.metadata.vertexCount;i++){const v=data.vertices[i];for(let j=0,jl=v.position.length;j<jl;j++)positions.push(v.position[j]);for(let j=0,jl=v.normal.length;j<jl;j++)normals.push(v.normal[j]);for(let j=0,jl=v.uv.length;j<jl;j++)uvs.push(v.uv[j]);for(let j=0;j<4;j++)skinIndices.push(v.skinIndices.length-1>=j?v.skinIndices[j]:0);for(let j=0;j<4;j++)skinWeights.push(v.skinWeights.length-1>=j?v.skinWeights[j]:0)}for(let i=0;i<data.metadata.faceCount;i++){const face=data.faces[i];for(let j=0,jl=face.indices.length;j<jl;j++)indices.push(face.indices[j])}for(let i=0;i<data.metadata.materialCount;i++){const material=data.materials[i];groups.push({offset:3*offset,count:3*material.faceCount}),offset+=material.faceCount}for(let i=0;i<data.metadata.rigidBodyCount;i++){const body=data.rigidBodies[i];let value=boneTypeTable[body.boneIndex];value=void 0===value?body.type:Math.max(body.type,value),boneTypeTable[body.boneIndex]=value}for(let i=0;i<data.metadata.boneCount;i++){const boneData=data.bones[i],bone={index:i,transformationClass:boneData.transformationClass,parent:boneData.parentIndex,name:boneData.name,pos:boneData.position.slice(0,3),rotq:[0,0,0,1],scl:[1,1,1],rigidBodyType:void 0!==boneTypeTable[i]?boneTypeTable[i]:-1};-1!==bone.parent&&(bone.pos[0]-=data.bones[bone.parent].position[0],bone.pos[1]-=data.bones[bone.parent].position[1],bone.pos[2]-=data.bones[bone.parent].position[2]),bones.push(bone)}if("pmd"===data.metadata.format)for(let i=0;i<data.metadata.ikCount;i++){const ik=data.iks[i],param={target:ik.target,effector:ik.effector,iteration:ik.iteration,maxAngle:4*ik.maxAngle,links:[]};for(let j=0,jl=ik.links.length;j<jl;j++){const link={};link.index=ik.links[j].index,link.enabled=!0,data.bones[link.index].name.indexOf("ひざ")>=0&&(link.limitation=new THREE.Vector3(1,0,0)),param.links.push(link)}iks.push(param)}else for(let i=0;i<data.metadata.boneCount;i++){const ik=data.bones[i].ik;if(void 0===ik)continue;const param={target:i,effector:ik.effector,iteration:ik.iteration,maxAngle:ik.maxAngle,links:[]};for(let j=0,jl=ik.links.length;j<jl;j++){const link={};if(link.index=ik.links[j].index,link.enabled=!0,1===ik.links[j].angleLimitation){const rotationMin=ik.links[j].lowerLimitationAngle,rotationMax=ik.links[j].upperLimitationAngle,tmp1=-rotationMax[0],tmp2=-rotationMax[1];rotationMax[0]=-rotationMin[0],rotationMax[1]=-rotationMin[1],rotationMin[0]=tmp1,rotationMin[1]=tmp2,link.rotationMin=(new THREE.Vector3).fromArray(rotationMin),link.rotationMax=(new THREE.Vector3).fromArray(rotationMax)}param.links.push(link)}iks.push(param),bones[i].ik=param}if("pmx"===data.metadata.format){const grantEntryMap={};for(let i=0;i<data.metadata.boneCount;i++){const boneData=data.bones[i],grant=boneData.grant;if(void 0===grant)continue;const param={index:i,parentIndex:grant.parentIndex,ratio:grant.ratio,isLocal:grant.isLocal,affectRotation:grant.affectRotation,affectPosition:grant.affectPosition,transformationClass:boneData.transformationClass};grantEntryMap[i]={parent:null,children:[],param:param,visited:!1}}const rootEntry={parent:null,children:[],param:null,visited:!1};for(const boneIndex in grantEntryMap){const grantEntry=grantEntryMap[boneIndex],parentGrantEntry=grantEntryMap[grantEntry.parentIndex]||rootEntry;grantEntry.parent=parentGrantEntry,parentGrantEntry.children.push(grantEntry)}function traverse(entry){entry.param&&(grants.push(entry.param),bones[entry.param.index].grant=entry.param),entry.visited=!0;for(let i=0,il=entry.children.length;i<il;i++){const child=entry.children[i];child.visited||traverse(child)}}traverse(rootEntry)}function updateAttributes(attribute,morph,ratio){for(let i=0;i<morph.elementCount;i++){const element=morph.elements[i];let index;index="pmd"===data.metadata.format?data.morphs[0].elements[element.index].index:element.index,attribute.array[3*index+0]+=element.position[0]*ratio,attribute.array[3*index+1]+=element.position[1]*ratio,attribute.array[3*index+2]+=element.position[2]*ratio}}for(let i=0;i<data.metadata.morphCount;i++){const morph=data.morphs[i],params={name:morph.name},attribute=new THREE.Float32BufferAttribute(3*data.metadata.vertexCount,3);attribute.name=morph.name;for(let j=0;j<3*data.metadata.vertexCount;j++)attribute.array[j]=positions[j];if("pmd"===data.metadata.format)0!==i&&updateAttributes(attribute,morph,1);else if(0===morph.type)for(let j=0;j<morph.elementCount;j++){const morph2=data.morphs[morph.elements[j].index],ratio=morph.elements[j].ratio;1===morph2.type&&updateAttributes(attribute,morph2,ratio)}else 1===morph.type?updateAttributes(attribute,morph,1):2===morph.type||3===morph.type||4===morph.type||5===morph.type||6===morph.type||7===morph.type||morph.type;morphTargets.push(params),morphPositions.push(attribute)}for(let i=0;i<data.metadata.rigidBodyCount;i++){const rigidBody=data.rigidBodies[i],params={};for(const key in rigidBody)params[key]=rigidBody[key];if("pmx"===data.metadata.format&&-1!==params.boneIndex){const bone=data.bones[params.boneIndex];params.position[0]-=bone.position[0],params.position[1]-=bone.position[1],params.position[2]-=bone.position[2]}rigidBodies.push(params)}for(let i=0;i<data.metadata.constraintCount;i++){const constraint=data.constraints[i],params={};for(const key in constraint)params[key]=constraint[key];const bodyA=rigidBodies[params.rigidBodyIndex1],bodyB=rigidBodies[params.rigidBodyIndex2];0!==bodyA.type&&2===bodyB.type&&-1!==bodyA.boneIndex&&-1!==bodyB.boneIndex&&data.bones[bodyB.boneIndex].parentIndex===bodyA.boneIndex&&(bodyB.type=1),constraints.push(params)}const geometry=new THREE.BufferGeometry;geometry.setAttribute("position",new THREE.Float32BufferAttribute(positions,3)),geometry.setAttribute("normal",new THREE.Float32BufferAttribute(normals,3)),geometry.setAttribute("uv",new THREE.Float32BufferAttribute(uvs,2)),geometry.setAttribute("skinIndex",new THREE.Uint16BufferAttribute(skinIndices,4)),geometry.setAttribute("skinWeight",new THREE.Float32BufferAttribute(skinWeights,4)),geometry.setIndex(indices);for(let i=0,il=groups.length;i<il;i++)geometry.addGroup(groups[i].offset,groups[i].count,i);return geometry.bones=bones,geometry.morphTargets=morphTargets,geometry.morphAttributes.position=morphPositions,geometry.morphTargetsRelative=!1,geometry.userData.MMD={bones:bones,iks:iks,grants:grants,rigidBodies:rigidBodies,constraints:constraints,format:data.metadata.format},geometry.computeBoundingSphere(),geometry}}class MaterialBuilder{constructor(manager){this.manager=manager,this.textureLoader=new THREE.TextureLoader(this.manager),this.tgaLoader=null,this.crossOrigin="anonymous",this.resourcePath=void 0}setCrossOrigin(crossOrigin){return this.crossOrigin=crossOrigin,this}setResourcePath(resourcePath){return this.resourcePath=resourcePath,this}build(data,geometry){const materials=[],textures={};this.textureLoader.setCrossOrigin(this.crossOrigin);for(let i=0;i<data.metadata.materialCount;i++){const material=data.materials[i],params={userData:{MMD:{}}};if(void 0!==material.name&&(params.name=material.name),params.diffuse=(new THREE.Color).fromArray(material.diffuse),params.opacity=material.diffuse[3],params.specular=(new THREE.Color).fromArray(material.specular),params.shininess=material.shininess,params.emissive=(new THREE.Color).fromArray(material.ambient),params.transparent=1!==params.opacity,params.fog=!0,params.blending=THREE.CustomBlending,params.blendSrc=THREE.SrcAlphaFactor,params.blendDst=THREE.OneMinusSrcAlphaFactor,params.blendSrcAlpha=THREE.SrcAlphaFactor,params.blendDstAlpha=THREE.DstAlphaFactor,"pmx"===data.metadata.format&&1==(1&material.flag)?params.side=THREE.DoubleSide:params.side=1===params.opacity?THREE.FrontSide:THREE.DoubleSide,"pmd"===data.metadata.format){if(material.fileName){const fileName=material.fileName,fileNames=fileName.split("*");if(params.map=this._loadTexture(fileNames[0],textures),fileNames.length>1){const extension=fileNames[1].slice(-4).toLowerCase();params.envMap=this._loadTexture(fileNames[1],textures),params.combine=".sph"===extension?THREE.MultiplyOperation:THREE.AddOperation}}const toonFileName=-1===material.toonIndex?"toon00.bmp":data.toonTextures[material.toonIndex].fileName;params.gradientMap=this._loadTexture(toonFileName,textures,{isToonTexture:!0,isDefaultToonTexture:this._isDefaultToonTexture(toonFileName)}),params.userData.outlineParameters={thickness:1===material.edgeFlag?.003:0,color:[0,0,0],alpha:1,visible:1===material.edgeFlag}}else{let toonFileName,isDefaultToon;-1!==material.textureIndex&&(params.map=this._loadTexture(data.textures[material.textureIndex],textures),params.userData.MMD.mapFileName=data.textures[material.textureIndex]),-1===material.envTextureIndex||1!==material.envFlag&&2!=material.envFlag||(params.matcap=this._loadTexture(data.textures[material.envTextureIndex],textures),params.userData.MMD.matcapFileName=data.textures[material.envTextureIndex],params.matcapCombine=1===material.envFlag?THREE.MultiplyOperation:THREE.AddOperation),-1===material.toonIndex||0!==material.toonFlag?(toonFileName="toon"+("0"+(material.toonIndex+1)).slice(-2)+".bmp",isDefaultToon=!0):(toonFileName=data.textures[material.toonIndex],isDefaultToon=!1),params.gradientMap=this._loadTexture(toonFileName,textures,{isToonTexture:!0,isDefaultToonTexture:isDefaultToon}),params.userData.outlineParameters={thickness:material.edgeSize/300,color:material.edgeColor.slice(0,3),alpha:material.edgeColor[3],visible:0!=(16&material.flag)&&material.edgeSize>0}}void 0!==params.map&&(params.transparent||this._checkImageTransparency(params.map,geometry,i),params.emissive.multiplyScalar(.2)),materials.push(new MMDToonMaterial(params))}if("pmx"===data.metadata.format){function checkAlphaMorph(elements,materials){for(let i=0,il=elements.length;i<il;i++){const element=elements[i];if(-1===element.index)continue;const material=materials[element.index];material.opacity!==element.diffuse[3]&&(material.transparent=!0)}}for(let i=0,il=data.morphs.length;i<il;i++){const morph=data.morphs[i],elements=morph.elements;if(0===morph.type)for(let j=0,jl=elements.length;j<jl;j++){const morph2=data.morphs[elements[j].index];8===morph2.type&&checkAlphaMorph(morph2.elements,materials)}else 8===morph.type&&checkAlphaMorph(elements,materials)}}return materials}_getTGALoader(){if(null===this.tgaLoader){if(void 0===THREE.TGALoader)throw new Error("THREE.MMDLoader: Import THREE.TGALoader");this.tgaLoader=new THREE.TGALoader(this.manager)}return this.tgaLoader}_isDefaultToonTexture(name){return 10===name.length&&/toon(10|0[0-9])\.bmp/.test(name)}_loadTexture(filePath,textures,params,onProgress,onError){const scope=this;let fullPath;if(!0===(params=params||{}).isDefaultToonTexture){let index;try{index=parseInt(filePath.match(/toon([0-9]{2})\.bmp$/)[1])}catch(e){console.warn("THREE.MMDLoader: "+filePath+" seems like a not right default texture path. Using toon00.bmp instead."),index=0}fullPath=DEFAULT_TOON_TEXTURES[index]}else fullPath=this.resourcePath+filePath;if(void 0!==textures[fullPath])return textures[fullPath];let loader=this.manager.getHandler(fullPath);null===loader&&(loader=".tga"===filePath.slice(-4).toLowerCase()?this._getTGALoader():this.textureLoader);const texture=loader.load(fullPath,(function(t){!0===params.isToonTexture&&(t.image=scope._getRotatedImage(t.image),t.magFilter=THREE.NearestFilter,t.minFilter=THREE.NearestFilter),t.flipY=!1,t.wrapS=THREE.RepeatWrapping,t.wrapT=THREE.RepeatWrapping;for(let i=0;i<texture.readyCallbacks.length;i++)texture.readyCallbacks[i](texture);delete texture.readyCallbacks}),onProgress,onError);return texture.readyCallbacks=[],textures[fullPath]=texture,texture}_getRotatedImage(image){const canvas=document.createElement("canvas"),context=canvas.getContext("2d"),width=image.width,height=image.height;return canvas.width=width,canvas.height=height,context.clearRect(0,0,width,height),context.translate(width/2,height/2),context.rotate(.5*Math.PI),context.translate(-width/2,-height/2),context.drawImage(image,0,0),context.getImageData(0,0,width,height)}_checkImageTransparency(map,geometry,groupIndex){map.readyCallbacks.push((function(texture){function createImageData(image){const canvas=document.createElement("canvas");canvas.width=image.width,canvas.height=image.height;const context=canvas.getContext("2d");return context.drawImage(image,0,0),context.getImageData(0,0,canvas.width,canvas.height)}function detectImageTransparency(image,uvs,indices){const width=image.width,height=image.height,data=image.data,threshold=253;if(data.length/(width*height)!=4)return!1;for(let i=0;i<indices.length;i+=3){const centerUV={x:0,y:0};for(let j=0;j<3;j++){const index=indices[3*i+j],uv={x:uvs[2*index+0],y:uvs[2*index+1]};if(getAlphaByUv(image,uv)<253)return!0;centerUV.x+=uv.x,centerUV.y+=uv.y}if(centerUV.x/=3,centerUV.y/=3,getAlphaByUv(image,centerUV)<253)return!0}return!1}function getAlphaByUv(image,uv){const width=image.width,height=image.height;let x=Math.round(uv.x*width)%width,y=Math.round(uv.y*height)%height;x<0&&(x+=width),y<0&&(y+=height);const index=y*width+x;return image.data[4*index+3]}if(!0===texture.isCompressedTexture)return void(NON_ALPHA_CHANNEL_FORMATS.includes(texture.format)?map.transparent=!1:map.transparent=!0);const imageData=void 0!==texture.image.data?texture.image:createImageData(texture.image),group=geometry.groups[groupIndex];detectImageTransparency(imageData,geometry.attributes.uv.array,geometry.index.array.slice(group.start,group.start+group.count))&&(map.transparent=!0)}))}}class AnimationBuilder{build(vmd,mesh){const tracks=this.buildSkeletalAnimation(vmd,mesh).tracks,tracks2=this.buildMorphAnimation(vmd,mesh).tracks;for(let i=0,il=tracks2.length;i<il;i++)tracks.push(tracks2[i]);return new THREE.AnimationClip("",-1,tracks)}buildSkeletalAnimation(vmd,mesh){function pushInterpolation(array,interpolation,index){array.push(interpolation[index+0]/127),array.push(interpolation[index+8]/127),array.push(interpolation[index+4]/127),array.push(interpolation[index+12]/127)}const tracks=[],motions={},bones=mesh.skeleton.bones,boneNameDictionary={};for(let i=0,il=bones.length;i<il;i++)boneNameDictionary[bones[i].name]=!0;for(let i=0;i<vmd.metadata.motionCount;i++){const motion=vmd.motions[i],boneName=motion.boneName;void 0!==boneNameDictionary[boneName]&&(motions[boneName]=motions[boneName]||[],motions[boneName].push(motion))}for(const key in motions){const array=motions[key];array.sort((function(a,b){return a.frameNum-b.frameNum}));const times=[],positions=[],rotations=[],pInterpolations=[],rInterpolations=[],basePosition=mesh.skeleton.getBoneByName(key).position.toArray();for(let i=0,il=array.length;i<il;i++){const time=array[i].frameNum/30,position=array[i].position,rotation=array[i].rotation,interpolation=array[i].interpolation;times.push(time);for(let j=0;j<3;j++)positions.push(basePosition[j]+position[j]);for(let j=0;j<4;j++)rotations.push(rotation[j]);for(let j=0;j<3;j++)pushInterpolation(pInterpolations,interpolation,j);pushInterpolation(rInterpolations,interpolation,3)}const targetName=".bones["+key+"]";tracks.push(this._createTrack(targetName+".position",THREE.VectorKeyframeTrack,times,positions,pInterpolations)),tracks.push(this._createTrack(targetName+".quaternion",THREE.QuaternionKeyframeTrack,times,rotations,rInterpolations))}return new THREE.AnimationClip("",-1,tracks)}buildMorphAnimation(vmd,mesh){const tracks=[],morphs={},morphTargetDictionary=mesh.morphTargetDictionary;for(let i=0;i<vmd.metadata.morphCount;i++){const morph=vmd.morphs[i],morphName=morph.morphName;void 0!==morphTargetDictionary[morphName]&&(morphs[morphName]=morphs[morphName]||[],morphs[morphName].push(morph))}for(const key in morphs){const array=morphs[key];array.sort((function(a,b){return a.frameNum-b.frameNum}));const times=[],values=[];for(let i=0,il=array.length;i<il;i++)times.push(array[i].frameNum/30),values.push(array[i].weight);tracks.push(new THREE.NumberKeyframeTrack(".morphTargetInfluences["+morphTargetDictionary[key]+"]",times,values))}return new THREE.AnimationClip("",-1,tracks)}buildCameraAnimation(vmd){function pushVector3(array,vec){array.push(vec.x),array.push(vec.y),array.push(vec.z)}function pushQuaternion(array,q){array.push(q.x),array.push(q.y),array.push(q.z),array.push(q.w)}function pushInterpolation(array,interpolation,index){array.push(interpolation[4*index+0]/127),array.push(interpolation[4*index+1]/127),array.push(interpolation[4*index+2]/127),array.push(interpolation[4*index+3]/127)}const cameras=void 0===vmd.cameras?[]:vmd.cameras.slice();cameras.sort((function(a,b){return a.frameNum-b.frameNum}));const times=[],centers=[],quaternions=[],positions=[],fovs=[],cInterpolations=[],qInterpolations=[],pInterpolations=[],fInterpolations=[],quaternion=new THREE.Quaternion,euler=new THREE.Euler,position=new THREE.Vector3,center=new THREE.Vector3;for(let i=0,il=cameras.length;i<il;i++){const motion=cameras[i],time=motion.frameNum/30,pos=motion.position,rot=motion.rotation,distance=motion.distance,fov=motion.fov,interpolation=motion.interpolation;times.push(time),position.set(0,0,-distance),center.set(pos[0],pos[1],pos[2]),euler.set(-rot[0],-rot[1],-rot[2]),quaternion.setFromEuler(euler),position.add(center),position.applyQuaternion(quaternion),pushVector3(centers,center),pushQuaternion(quaternions,quaternion),pushVector3(positions,position),fovs.push(fov);for(let j=0;j<3;j++)pushInterpolation(cInterpolations,interpolation,j);pushInterpolation(qInterpolations,interpolation,3);for(let j=0;j<3;j++)pushInterpolation(pInterpolations,interpolation,4);pushInterpolation(fInterpolations,interpolation,5)}const tracks=[];return tracks.push(this._createTrack("target.position",THREE.VectorKeyframeTrack,times,centers,cInterpolations)),tracks.push(this._createTrack(".quaternion",THREE.QuaternionKeyframeTrack,times,quaternions,qInterpolations)),tracks.push(this._createTrack(".position",THREE.VectorKeyframeTrack,times,positions,pInterpolations)),tracks.push(this._createTrack(".fov",THREE.NumberKeyframeTrack,times,fovs,fInterpolations)),new THREE.AnimationClip("",-1,tracks)}_createTrack(node,typedKeyframeTrack,times,values,interpolations){if(times.length>2){times=times.slice(),values=values.slice(),interpolations=interpolations.slice();const stride=values.length/times.length,interpolateStride=interpolations.length/times.length;let index=1;for(let aheadIndex=2,endIndex=times.length;aheadIndex<endIndex;aheadIndex++){for(let i=0;i<stride;i++)if(values[index*stride+i]!==values[(index-1)*stride+i]||values[index*stride+i]!==values[aheadIndex*stride+i]){index++;break}if(aheadIndex>index){times[index]=times[aheadIndex];for(let i=0;i<stride;i++)values[index*stride+i]=values[aheadIndex*stride+i];for(let i=0;i<interpolateStride;i++)interpolations[index*interpolateStride+i]=interpolations[aheadIndex*interpolateStride+i]}}times.length=index+1,values.length=(index+1)*stride,interpolations.length=(index+1)*interpolateStride}const track=new typedKeyframeTrack(node,times,values);return track.createInterpolant=function InterpolantFactoryMethodCubicBezier(result){return new CubicBezierInterpolation(this.times,this.values,this.getValueSize(),result,new Float32Array(interpolations))},track}}class CubicBezierInterpolation extends THREE.Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer,params){super(parameterPositions,sampleValues,sampleSize,resultBuffer),this.interpolationParams=params}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,params=this.interpolationParams,offset1=i1*stride,offset0=offset1-stride,weight1=t1-t0<.05?0:(t-t0)/(t1-t0);if(4===stride){const x1=params[4*i1+0],x2=params[4*i1+1],y1=params[4*i1+2],y2=params[4*i1+3],ratio=this._calculate(x1,x2,y1,y2,weight1);THREE.Quaternion.slerpFlat(result,0,values,offset0,values,offset1,ratio)}else if(3===stride)for(let i=0;i!==stride;++i){const x1=params[12*i1+4*i+0],x2=params[12*i1+4*i+1],y1=params[12*i1+4*i+2],y2=params[12*i1+4*i+3],ratio=this._calculate(x1,x2,y1,y2,weight1);result[i]=values[offset0+i]*(1-ratio)+values[offset1+i]*ratio}else{const x1=params[4*i1+0],x2=params[4*i1+1],y1=params[4*i1+2],y2=params[4*i1+3],ratio=this._calculate(x1,x2,y1,y2,weight1);result[0]=values[offset0]*(1-ratio)+values[offset1]*ratio}return result}_calculate(x1,x2,y1,y2,x){let c=.5,t=c,s=1-t;const loop=15,eps=1e-5,math=Math;let sst3,stt3,ttt;for(let i=0;i<15;i++){sst3=3*s*s*t,stt3=3*s*t*t,ttt=t*t*t;const ft=sst3*x1+stt3*x2+ttt-x;if(math.abs(ft)<eps)break;c/=2,t+=ft<0?c:-c,s=1-t}return sst3*y1+stt3*y2+ttt}}class MMDToonMaterial extends THREE.ShaderMaterial{constructor(parameters){super(),this.isMMDToonMaterial=!0,this._matcapCombine=THREE.AddOperation,this.emissiveIntensity=1,this.normalMapType=THREE.TangentSpaceNormalMap,this.combine=THREE.MultiplyOperation,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.lights=!0,this.vertexShader=THREE.MMDToonShader.vertexShader,this.fragmentShader=THREE.MMDToonShader.fragmentShader,this.defines=Object.assign({},THREE.MMDToonShader.defines),Object.defineProperty(this,"matcapCombine",{get:function(){return this._matcapCombine},set:function(value){switch(this._matcapCombine=value,value){case THREE.MultiplyOperation:this.defines.MATCAP_BLENDING_MULTIPLY=!0,delete this.defines.MATCAP_BLENDING_ADD;break;default:case THREE.AddOperation:this.defines.MATCAP_BLENDING_ADD=!0,delete this.defines.MATCAP_BLENDING_MULTIPLY}}}),this.uniforms=THREE.UniformsUtils.clone(THREE.MMDToonShader.uniforms);const exposePropertyNames=["specular","opacity","diffuse","map","matcap","gradientMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveMap","bumpMap","bumpScale","normalMap","normalScale","displacemantBias","displacemantMap","displacemantScale","specularMap","alphaMap","envMap","reflectivity","refractionRatio"];for(const propertyName of exposePropertyNames)Object.defineProperty(this,propertyName,{get:function(){return this.uniforms[propertyName].value},set:function(value){this.uniforms[propertyName].value=value}});this._shininess=30,Object.defineProperty(this,"shininess",{get:function(){return this._shininess},set:function(value){this._shininess=value,this.uniforms.shininess.value=Math.max(this._shininess,1e-4)}}),Object.defineProperty(this,"color",Object.getOwnPropertyDescriptor(this,"diffuse")),this.setValues(parameters)}copy(source){return super.copy(source),this.matcapCombine=source.matcapCombine,this.emissiveIntensity=source.emissiveIntensity,this.normalMapType=source.normalMapType,this.combine=source.combine,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this}}THREE.MMDLoader=MMDLoader}();