THREE.OBJLoader=function(){var object_pattern=/^[og]\s*(.+)?/,material_library_pattern=/^mtllib /,material_use_pattern=/^usemtl /,map_use_pattern=/^usemap /,vA=new THREE.Vector3,vB=new THREE.Vector3,vC=new THREE.Vector3,ab=new THREE.Vector3,cb=new THREE.Vector3;function ParserState(){var state={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(name,fromDeclaration){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=name,void(this.object.fromDeclaration=!1!==fromDeclaration);var previousMaterial=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:name||"",fromDeclaration:!1!==fromDeclaration,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(name,libraries){var previous=this._finalize(!1);previous&&(previous.inherited||previous.groupCount<=0)&&this.materials.splice(previous.index,1);var material={index:this.materials.length,name:name||"",mtllib:Array.isArray(libraries)&&libraries.length>0?libraries[libraries.length-1]:"",smooth:void 0!==previous?previous.smooth:this.smooth,groupStart:void 0!==previous?previous.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(index){var cloned={index:"number"==typeof index?index:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return cloned.clone=this.clone.bind(cloned),cloned}};return this.materials.push(material),material},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(end){var lastMultiMaterial=this.currentMaterial();if(lastMultiMaterial&&-1===lastMultiMaterial.groupEnd&&(lastMultiMaterial.groupEnd=this.geometry.vertices.length/3,lastMultiMaterial.groupCount=lastMultiMaterial.groupEnd-lastMultiMaterial.groupStart,lastMultiMaterial.inherited=!1),end&&this.materials.length>1)for(var mi=this.materials.length-1;mi>=0;mi--)this.materials[mi].groupCount<=0&&this.materials.splice(mi,1);return end&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),lastMultiMaterial}},previousMaterial&&previousMaterial.name&&"function"==typeof previousMaterial.clone){var declared=previousMaterial.clone(0);declared.inherited=!0,this.object.materials.push(declared)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(value,len){var index=parseInt(value,10);return 3*(index>=0?index-1:index+len/3)},parseNormalIndex:function(value,len){var index=parseInt(value,10);return 3*(index>=0?index-1:index+len/3)},parseUVIndex:function(value,len){var index=parseInt(value,10);return 2*(index>=0?index-1:index+len/2)},addVertex:function(a,b,c){var src=this.vertices,dst=this.object.geometry.vertices;dst.push(src[a+0],src[a+1],src[a+2]),dst.push(src[b+0],src[b+1],src[b+2]),dst.push(src[c+0],src[c+1],src[c+2])},addVertexPoint:function(a){var src=this.vertices,dst;this.object.geometry.vertices.push(src[a+0],src[a+1],src[a+2])},addVertexLine:function(a){var src=this.vertices,dst;this.object.geometry.vertices.push(src[a+0],src[a+1],src[a+2])},addNormal:function(a,b,c){var src=this.normals,dst=this.object.geometry.normals;dst.push(src[a+0],src[a+1],src[a+2]),dst.push(src[b+0],src[b+1],src[b+2]),dst.push(src[c+0],src[c+1],src[c+2])},addFaceNormal:function(a,b,c){var src=this.vertices,dst=this.object.geometry.normals;vA.fromArray(src,a),vB.fromArray(src,b),vC.fromArray(src,c),cb.subVectors(vC,vB),ab.subVectors(vA,vB),cb.cross(ab),cb.normalize(),dst.push(cb.x,cb.y,cb.z),dst.push(cb.x,cb.y,cb.z),dst.push(cb.x,cb.y,cb.z)},addColor:function(a,b,c){var src=this.colors,dst=this.object.geometry.colors;void 0!==src[a]&&dst.push(src[a+0],src[a+1],src[a+2]),void 0!==src[b]&&dst.push(src[b+0],src[b+1],src[b+2]),void 0!==src[c]&&dst.push(src[c+0],src[c+1],src[c+2])},addUV:function(a,b,c){var src=this.uvs,dst=this.object.geometry.uvs;dst.push(src[a+0],src[a+1]),dst.push(src[b+0],src[b+1]),dst.push(src[c+0],src[c+1])},addDefaultUV:function(){var dst=this.object.geometry.uvs;dst.push(0,0),dst.push(0,0),dst.push(0,0)},addUVLine:function(a){var src=this.uvs,dst;this.object.geometry.uvs.push(src[a+0],src[a+1])},addFace:function(a,b,c,ua,ub,uc,na,nb,nc){var vLen=this.vertices.length,ia=this.parseVertexIndex(a,vLen),ib=this.parseVertexIndex(b,vLen),ic=this.parseVertexIndex(c,vLen);if(this.addVertex(ia,ib,ic),this.addColor(ia,ib,ic),void 0!==na&&""!==na){var nLen=this.normals.length;ia=this.parseNormalIndex(na,nLen),ib=this.parseNormalIndex(nb,nLen),ic=this.parseNormalIndex(nc,nLen),this.addNormal(ia,ib,ic)}else this.addFaceNormal(ia,ib,ic);if(void 0!==ua&&""!==ua){var uvLen=this.uvs.length;ia=this.parseUVIndex(ua,uvLen),ib=this.parseUVIndex(ub,uvLen),ic=this.parseUVIndex(uc,uvLen),this.addUV(ia,ib,ic),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(vertices){this.object.geometry.type="Points";for(var vLen=this.vertices.length,vi=0,l=vertices.length;vi<l;vi++){var index=this.parseVertexIndex(vertices[vi],vLen);this.addVertexPoint(index),this.addColor(index)}},addLineGeometry:function(vertices,uvs){this.object.geometry.type="Line";for(var vLen=this.vertices.length,uvLen=this.uvs.length,vi=0,l=vertices.length;vi<l;vi++)this.addVertexLine(this.parseVertexIndex(vertices[vi],vLen));for(var uvi=0,l=uvs.length;uvi<l;uvi++)this.addUVLine(this.parseUVIndex(uvs[uvi],uvLen))}};return state.startObject("",!1),state}function OBJLoader(manager){THREE.Loader.call(this,manager),this.materials=null}return OBJLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:OBJLoader,load:function(url,onLoad,onProgress,onError){var scope=this,loader=new THREE.FileLoader(this.manager);loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,(function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}}),onProgress,onError)},setMaterials:function(materials){return this.materials=materials,this},parse:function(text){var state=new ParserState;-1!==text.indexOf("\r\n")&&(text=text.replace(/\r\n/g,"\n")),-1!==text.indexOf("\\\n")&&(text=text.replace(/\\\n/g,""));for(var lines=text.split("\n"),line="",lineFirstChar="",lineLength=0,result=[],trimLeft="function"==typeof"".trimLeft,i=0,l=lines.length;i<l;i++)if(line=lines[i],0!==(lineLength=(line=trimLeft?line.trimLeft():line.trim()).length)&&"#"!==(lineFirstChar=line.charAt(0)))if("v"===lineFirstChar){var data=line.split(/\s+/);switch(data[0]){case"v":state.vertices.push(parseFloat(data[1]),parseFloat(data[2]),parseFloat(data[3])),data.length>=7?state.colors.push(parseFloat(data[4]),parseFloat(data[5]),parseFloat(data[6])):state.colors.push(void 0,void 0,void 0);break;case"vn":state.normals.push(parseFloat(data[1]),parseFloat(data[2]),parseFloat(data[3]));break;case"vt":state.uvs.push(parseFloat(data[1]),parseFloat(data[2]))}}else if("f"===lineFirstChar){for(var lineData,vertexData=(lineData=line.substr(1).trim()).split(/\s+/),faceVertices=[],j=0,jl=vertexData.length;j<jl;j++){var vertex=vertexData[j];if(vertex.length>0){var vertexParts=vertex.split("/");faceVertices.push(vertexParts)}}for(var v1=faceVertices[0],j=1,jl=faceVertices.length-1;j<jl;j++){var v2=faceVertices[j],v3=faceVertices[j+1];state.addFace(v1[0],v2[0],v3[0],v1[1],v2[1],v3[1],v1[2],v2[2],v3[2])}}else if("l"===lineFirstChar){var lineParts=line.substring(1).trim().split(" "),lineVertices=[],lineUVs=[];if(-1===line.indexOf("/"))lineVertices=lineParts;else for(var li=0,llen=lineParts.length;li<llen;li++){var parts=lineParts[li].split("/");""!==parts[0]&&lineVertices.push(parts[0]),""!==parts[1]&&lineUVs.push(parts[1])}state.addLineGeometry(lineVertices,lineUVs)}else if("p"===lineFirstChar){var lineData,pointData=(lineData=line.substr(1).trim()).split(" ");state.addPointGeometry(pointData)}else if(null!==(result=object_pattern.exec(line))){var name=(" "+result[0].substr(1).trim()).substr(1);state.startObject(name)}else if(material_use_pattern.test(line))state.object.startMaterial(line.substring(7).trim(),state.materialLibraries);else if(material_library_pattern.test(line))state.materialLibraries.push(line.substring(7).trim());else if(map_use_pattern.test(line))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===lineFirstChar){if((result=line.split(" ")).length>1){var value=result[1].trim().toLowerCase();state.object.smooth="0"!==value&&"off"!==value}else state.object.smooth=!0;var material;(material=state.object.currentMaterial())&&(material.smooth=state.object.smooth)}else{if("\0"===line)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+line+'"')}state.finalize();var container=new THREE.Group,hasPrimitives;if(container.materialLibraries=[].concat(state.materialLibraries),!0===!(1===state.objects.length&&0===state.objects[0].geometry.vertices.length))for(var i=0,l=state.objects.length;i<l;i++){var object=state.objects[i],geometry=object.geometry,materials=object.materials,isLine="Line"===geometry.type,isPoints="Points"===geometry.type,hasVertexColors=!1;if(0!==geometry.vertices.length){var buffergeometry;(buffergeometry=new THREE.BufferGeometry).setAttribute("position",new THREE.Float32BufferAttribute(geometry.vertices,3)),geometry.normals.length>0&&buffergeometry.setAttribute("normal",new THREE.Float32BufferAttribute(geometry.normals,3)),geometry.colors.length>0&&(hasVertexColors=!0,buffergeometry.setAttribute("color",new THREE.Float32BufferAttribute(geometry.colors,3))),!0===geometry.hasUVIndices&&buffergeometry.setAttribute("uv",new THREE.Float32BufferAttribute(geometry.uvs,2));for(var createdMaterials=[],mi=0,miLen=materials.length,mesh;mi<miLen;mi++){var sourceMaterial,materialHash=(sourceMaterial=materials[mi]).name+"_"+sourceMaterial.smooth+"_"+hasVertexColors,material=state.materials[materialHash];if(null!==this.materials)if(material=this.materials.create(sourceMaterial.name),!isLine||!material||material instanceof THREE.LineBasicMaterial){if(isPoints&&material&&!(material instanceof THREE.PointsMaterial)){var materialPoints=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(materialPoints,material),materialPoints.color.copy(material.color),materialPoints.map=material.map,material=materialPoints}}else{var materialLine=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(materialLine,material),materialLine.color.copy(material.color),material=materialLine}void 0===material&&((material=isLine?new THREE.LineBasicMaterial:isPoints?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial).name=sourceMaterial.name,material.flatShading=!sourceMaterial.smooth,material.vertexColors=hasVertexColors,state.materials[materialHash]=material),createdMaterials.push(material)}if(createdMaterials.length>1){for(var mi=0,miLen=materials.length;mi<miLen;mi++){var sourceMaterial=materials[mi];buffergeometry.addGroup(sourceMaterial.groupStart,sourceMaterial.groupCount,mi)}mesh=isLine?new THREE.LineSegments(buffergeometry,createdMaterials):isPoints?new THREE.Points(buffergeometry,createdMaterials):new THREE.Mesh(buffergeometry,createdMaterials)}else mesh=isLine?new THREE.LineSegments(buffergeometry,createdMaterials[0]):isPoints?new THREE.Points(buffergeometry,createdMaterials[0]):new THREE.Mesh(buffergeometry,createdMaterials[0]);mesh.name=object.name,container.add(mesh)}}else if(state.vertices.length>0){var material=new THREE.PointsMaterial({size:1,sizeAttenuation:!1}),buffergeometry;(buffergeometry=new THREE.BufferGeometry).setAttribute("position",new THREE.Float32BufferAttribute(state.vertices,3)),state.colors.length>0&&(buffergeometry.setAttribute("color",new THREE.Float32BufferAttribute(state.colors,3)),material.vertexColors=!0);var points=new THREE.Points(buffergeometry,material);container.add(points)}return container}}),OBJLoader}();